import re
import json
from abc import ABC, abstractmethod
from typing import Dict, Any, Tuple, Optional, List

# NOTE: Code generated by R1

class ToolMeta(type):
    def __init__(cls, name, bases, attrs):
        super().__init__(name, bases, attrs)
        # 跳过基类
        if name == 'ToolBase':
            return
        # 确保子类定义了 name 属性
        if not hasattr(cls, 'name'):
            raise AttributeError(f"Tool subclass {name} must define a 'name' attribute.")
        # 检查 name 是否已注册
        if cls.name in ToolBase.registry:
            existing = ToolBase.registry[cls.name]
            raise ValueError(f"Name '{cls.name}' already registered by {existing.__name__}")
        # 注册到基类的 registry
        ToolBase.registry[cls.name] = cls


class ToolBase(metaclass=ToolMeta):
    registry = {}  # 全局注册表

    def __init__(self, name: str, description: str, parameters: Dict = None, **kwargs):
        """
        Code adapted from: https://github.com/0russwest0/Agent-R1/blob/main/agent_r1/tool/tool_base.py
        Initialize the tool
        
        Args:
            name: Tool name
            description: Tool description
            parameters: JSON Schema compliant parameter definition, format as follows:
            {
                "type": "object",
                "properties": {
                    "param1": {"type": "string", "description": "Parameter 1 description"},
                    "param2": {"type": "number", "description": "Parameter 2 description"}
                },
                "required": ["param1"]
            }
        """
        self.name = name
        self.description = description
        self.parameters = parameters or {
            "type": "object",
            "properties": {},
            "required": []
        }

    @classmethod
    def create(cls, name, description, parameters, **kwargs):
        """
        Usage example:

        ```python
        hammer = ToolBase.create("hammer")
        wrench = ToolBase.create("wrench")

        tool_class = ToolBase.registry["hammer"]
        another_hammer = tool_class()
        ```
        """
        tool_cls = cls.registry.get(name)
        if not tool_cls:
            raise ValueError(f"No tool registered with name '{name}'")
        return tool_cls(name, description, parameters, **kwargs)

    @classmethod
    def from_system_prompt(cls, config, system_prompt, **kwargs):
        """
        Initialize a list of tools from Qwen2.5 style system prompt
        Refer to: https://qwen.readthedocs.io/en/latest/framework/function_call.html#qwen2-5-function-calling-templates
        """
        pattern = re.escape(config.tool_desc_start) + r'(.*?)' + re.escape(config.tool_desc_end)
        matches = re.findall(pattern, system_prompt, re.DOTALL)
        if not matches:
            return []

        tool_desc_lines = matches[-1].split('\n')
        result_tools = []
        for tool_desc in tool_desc_lines:
            if tool_desc.strip() == '':
                continue

            try:
                tool_info = json.loads(tool_desc)
                name = tool_info['function']['name']
                desc_text = tool_info['function']['description']
                params = tool_info['function']['parameters']
                tool_cls = cls.registry.get(name)
                if not tool_cls:
                    continue
                new_tool = tool_cls(name, desc_text, params, **kwargs)
            except Exception as err:
                print(f' [ERROR] {err=}')
                continue
            
            result_tools.append(new_tool)
        return result_tools

    def get_description(self) -> Dict:
        """
        Get the tool description in Dict format
        
        Returns:
            Dictionary containing name, description, and parameters
        """
        function_desc = {
            "name": self.name,
            "description": self.description,
            "parameters": self.parameters,
        }
        return {"type": "function", "function": function_desc}

    def get_json_description(self) -> str:
        """
        Get the tool description in JSON Schema format
        
        Returns:
            JSON string for function descriptions
        """
        return json.dumps(self.get_description(), indent=4, ensure_ascii=False)

    @abstractmethod
    def execute(self, *args, **kwargs) -> str:
        """
        Execute the tool functionality
        
        Args:
            args: Tool parameters
            
        Returns:
            tool_result: type string, tool execution result
            reward: float, procedual reward given by tool env
        """
        pass

    def validate_args(self, args: Dict) -> Tuple[bool, str]:
        """
        Validate if the tool parameters are valid
        
        Args:
            args: Tool parameters
            
        Returns:
            (is_valid, error_message)
        """
        # Check if args is a Dict
        if not isinstance(args, dict):
            return False, "Arguments must be a dictionary"

        # Check required parameters
        required_params = self.parameters.get("required", [])
        for param in required_params:
            if param not in args:
                return False, f"Missing required parameter: {param}"
        
        # Check parameter types
        properties = self.parameters.get("properties", {})
        for param_name, param_value in args.items():
            if param_name in properties:
                param_schema = properties[param_name]
                
                # Check type
                param_type = param_schema.get("type")
                if param_type and not self._check_type(param_value, param_type):
                    return False, f"Parameter {param_name} has incorrect type, should be {param_type}"
                
                # Check enum values
                if "enum" in param_schema and param_value not in param_schema["enum"]:
                    valid_values = ", ".join(map(str, param_schema["enum"]))
                    return False, f"Parameter {param_name} has invalid value, should be one of: {valid_values}"
        
        return True, "Parameters valid"

    def check_type(self, value: Any, expected_type: str) -> bool:
        """
        Check if the value's type matches the expected type
        
        Args:
            value: Value to check
            expected_type: Expected type
            
        Returns:
            Whether the type matches
        """
        if expected_type == "string":
            return isinstance(value, str)
        elif expected_type == "number":
            return isinstance(value, (int, float))
        elif expected_type == "integer":
            return isinstance(value, int)
        elif expected_type == "boolean":
            return isinstance(value, bool)
        elif expected_type == "array":
            return isinstance(value, list)
        elif expected_type == "object":
            return isinstance(value, dict)
        return True  # If unknown type, default to pass